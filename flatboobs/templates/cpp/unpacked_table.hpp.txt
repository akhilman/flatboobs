{% set flatbuffer_class = utils.flatbuffer_class(struct_def) %}
{% set unpacked_class = utils.unpacked_class(struct_def) %}
{% set fields = struct_def.fields|rejectattr("attributes.deprecated")|list %}

/* {{ flatbuffer_class }} */

class {{ flatbuffer_class }} final : private flatbuffers::Table {
public:
  enum {
    {% for field in fields %}
      VT_{{ utils.escape(field.name)|upper }} = {{ field.value.offset }},
    {% endfor %}
  };

{% for field in fields %}
  inline {{ utils.flatbuffer_type(field.value.type) }} {# -#}
    {{ utils.escape(field.name) }}() const
  { return GetField<{{ utils.flatbuffer_type(field.value.type) }}>(
      VT_{{- utils.escape(field.name)|upper -}}
      {% if field.value.type.base_type.is_scalar() %}
      , {{ field.value.constant }});
      {% endif %} }
{% endfor %}

  bool Verify(flatbuffers::Verifier &verifier) const;
};

/* {{ unpacked_class }} */

class {{ unpacked_class }} {
public:
  explicit {{ unpacked_class }}(flatboobs::Data);
  explicit {{ unpacked_class }}(
    flatboobs::Data, const {{ flatbuffer_class }} *);

  // Metadata

  inline flatboobs::content_id_t content_id() const {
    return flatboobs::content_id_t(flatbuf_);
  }

  // Getters
{% for field in fields %}
  {{ utils.cpp_type(field.value.type) }} {{
    utils.escape(field.name) }}() const;
{% endfor %}

private:
  const flatboobs::Data message_;
  const {{ flatbuffer_class }} *flatbuf_;

};


{#
// vim: syntax=cpp
// vim: tabstop=2
// vim: shiftwidth=2
#}
