/* {{ iface_type }} */

const {{ iface_type }}::value_variant_type
    {{ iface_type }}::operator[](const std::string &key) const
{
{% for field in fields %}
  if (key == "{{ field.name }}")
    return {{ utils.escape(field.name) }}();
{% endfor %}
  throw flatboobs::key_error(key);
}

bool operator== (const {{ iface_type }} &lhs, const {{ iface_type }} &rhs){
  return
  {% for field in fields %}
    lhs.{{ utils.escape(field.name) }}()
    == rhs.{{ utils.escape(field.name) }}()
  {%- if not loop.last %}
  &&
  {% endif %}
  {% endfor %}
  ;
}
bool operator!= (const {{ iface_type }} &lhs, const {{ iface_type }} &rhs){
  return !(lhs == rhs);
}

std::ostream& operator<< (std::ostream &stream, const {{ iface_type }} &src) {
  stream << "{{ iface_type }}("
  {% for field in fields %}
      << "{{ field.name }}="
  {% if field.value.type.base_type == BaseType.BOOL %}
      << (src.{{ utils.escape(field.name) }}()
          ? "true" : "false")
  {% elif field.value.type.definition is instance_of("EnumDef") %}
      << {{ field.value.type|to_cpp_type }}_to_string(src.{{
        utils.escape(field.name) }}())
  {% elif field.value.type.base_type.is_scalar() %}
      << +src.{{ utils.escape(field.name) }}()
  {% elif field.value.type.base_type == BaseType.STRING %}
    << '"' << src.{{ utils.escape(field.name) }}() << '"'
  {% else %}
      << src.{{ utils.escape(field.name) }}()
  {% endif %}
  {% if not loop.last %}
    << ", "
  {% endif %}
  {% endfor %}
    << ")";
  return stream;
};

// Builder

flatbuffers::Offset<{{ flatbuffer_type }}> {{ iface_type }}::build(
    flatbuffers::FlatBufferBuilder & _fbb,
    bool _finish
) const {

  std::map<flatboobs::content_id_t, flatbuffers::uoffset_t> offset_map{};

  flatbuffers::Offset<{{ flatbuffer_type }}> offset = build( _fbb, offset_map);
  if (_finish) {
    auto ident = file_identifier();
    const char *ident_ptr = (ident.size() ? ident.data() : nullptr);
    _fbb.Finish(offset, ident_ptr);
  }
  return offset;
}


flatbuffers::Offset<{{ flatbuffer_type }}> {{ iface_type }}::build(
    flatbuffers::FlatBufferBuilder & _fbb,
    std::map<flatboobs::content_id_t, flatbuffers::uoffset_t> &_offset_map
) const {

  auto it = _offset_map.find(content_id());
  if (it != _offset_map.end())
    return flatbuffers::Offset<{{ flatbuffer_type }}>{it->second};

  flatbuffers::uoffset_t start;
  start = _fbb.StartTable();
{% for field in fields|sort(attribute="value.type.inline_size") %}
{% if field.value.type.definition is instance_of("EnumDef") %}
  _fbb.AddElement<{{ field.value.type|to_flatbuf_type }}>(
    {{ flatbuffer_type }}::VT_{{ field.name|upper }},
    static_cast<{{ field.value.type|to_flatbuf_type }}>({{
    utils.escape(field.name) }}()),
    {{ field.value.constant }}
    );
{% elif field.value.type.base_type.is_scalar() %}
  _fbb.AddElement<{{ field.value.type|to_cpp_type }}>(
    {{ flatbuffer_type }}::VT_{{ field.name|upper }},
    {{ utils.escape(field.name) }}(),
    {{ field.value.constant }}
    );
{% else %}
  // TODO {{ field }}
{% endif %}
{% endfor %}
  flatbuffers::uoffset_t end = _fbb.EndTable(start);
  _offset_map[content_id()] = end;
  flatbuffers::Offset<{{ flatbuffer_type }}> offset {end};
  return offset;
}

{#
// vim: syntax=cpp
// vim: tabstop=2
// vim: shiftwidth=2
#}
