{% import "cpp/utils.txt" as utils %}
/*
 * Generated by FlatBoobs from {{ schema_file|basename }}
 */

#ifndef {{ output_file|include_guard }}
#define {{ output_file|include_guard }}

#include <cassert>
#include <map>
#include <sstream>
#include <variant>

#include <flatboobs/flatboobs.hpp>

{% for name in parser.included_files.values()|reject("eq", "") %}
#include "{{ library_name }}/{{ name|stem }}.hpp"
{% endfor %}


/*
 * Forvard declaration
 */

{% for group in parser.types
    | map(attribute="definition")
    | select("defined_here", parser)
    | groupby("defined_namespace") %}
{% for component in group.grouper.components %}
namespace {{ utils.escape(component) }} {
{% endfor %}

{% for definition in group.list|sort(attribute="name") %}
{% set class_name = utils.class_name(definition) %}
{% if definition is instance_of("StructDef") and definition.fixed %}
struct {{ class_name }};
{% elif definition is instance_of("EnumDef") %}
enum class {{ class_name }} : {{ utils.flatbuffer_type(definition.underlying_type) }};
{% else %}
class {{ class_name }};
{% endif %}
{% endfor %}

{% for component in group.grouper.components|reverse %}
}  // {{ utils.escape(component) }}
{% endfor %}
{% endfor %}

/*
 * Template specializationt declaration
 */

namespace flatboobs {

{% for struct_def in parser.structs|select("defined_here", parser)
      |rejectattr("fixed")|sort(attribute="name") %}
{% set class_name %}
  {{- utils.namespace(struct_def.defined_namespace) -}}
  ::{{ utils.class_name(struct_def) -}}
{% endset %}
extern template Message pack({{ class_name }});
extern template {{ class_name }} unpack<{{ class_name }}>(Message);
{% endfor %}

{% for struct_def in parser.structs|select("defined_here", parser)
        |rejectattr("fixed")|sort(attribute="name") %}
{% for field in struct_def.fields
    |selectattr("value.type.base_type", "eq", BaseType.VECTOR) %}
extern template class {{ utils.cpp_type(field.value.type) }};
extern template class VectorIterator<{{- utils.cpp_type(field.value.type) }}>;
{% endfor %}
{% endfor %}

}


{% for group in parser.types
    | map("attr", "definition")
    | select("defined_here", parser)
    | groupby("defined_namespace") %}
{% for component in group.grouper.components %}
namespace {{ utils.escape(component) }} {
{% endfor %}

/*
 * Declaration of enums
 */

{% for enum_def in group.list|select("instance_of", "EnumDef")
        |sort(attribute="name") %}
{% include "cpp/enum.hpp.txt" %}
{% endfor %}

/*
 * Declaration of structs
 */

{% for struct_def in group.list|select("instance_of", "StructDef")
        |selectattr("fixed") |sort(attribute="name") %}
{% include "cpp/mutable_struct.hpp.txt" %}
{% endfor %}

/*
 * Declaration of tables
 */

{% for struct_def in group.list|select("instance_of", "StructDef")
        |rejectattr("fixed")|sort(attribute="name") %}
{% include "cpp/table.hpp.txt" %}
{% endfor %}

{% for component in group.grouper.components|reverse %}
}  // {{ utils.escape(component) }}
{% endfor %}
{% endfor %}

{% if header_only %}
{% include "cpp/main.cpp.txt" %}
{% endif %}


#endif  // {{ output_file|include_guard }}

{#
// vim: syntax=cpp
// vim: tabstop=2
// vim: shiftwidth=2
#}
