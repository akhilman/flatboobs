{% set class_name = utils.class_name(struct_def) %}
{% set default_class = utils.default_class(struct_def) %}
{% set mutable_class = utils.mutable_class(struct_def) %}
{% set flatbuffer_class = utils.flatbuffer_class(struct_def) %}
{% set unpacked_class = utils.unpacked_class(struct_def) %}
{% set fields = struct_def.fields|rejectattr("attributes.deprecated")|list %}

{% include "cpp/default_table.cpp.txt" %}
{% include "cpp/mutable_struct.hpp.txt" %}
{% include "cpp/mutable_struct.cpp.txt" %}
{% include "cpp/unpacked_table.cpp.txt" %}

/* {{ class_name }} */

// Constructor
{{ class_name }}::{{ class_name }}()
  : impl_{std::make_shared<{{ default_class }}>()} {}
{{ class_name }}::{{ class_name }}({{ mutable_class }} _impl)
  : impl_{std::make_shared<{{ mutable_class }}>(std::move(_impl))} {}
{{ class_name }}::{{ class_name }}(flatboobs::Message _message)
  : impl_{std::make_shared<{{ unpacked_class }}>(std::move(_message))} {}

{{ class_name }}::{{ class_name }}(
{% for field in fields %}
  {{ utils.cpp_type(field.value.type) }} _{{ utils.escape(field.name) }}
    {{- "," if not loop.last }}
{% endfor %}
) : impl_{std::make_shared<{{ mutable_class }}>(
  {% for field_name in fields|map("attr", "name") %}
     std::move(_{{ utils.escape(field_name) }})
     {{- "," if not loop.last }}
  {% endfor %}
  )} {}

{{ class_name }}::{{ class_name }}(
    flatboobs::Message _message,
    const {{ flatbuffer_class }} *_flatbuf
) : impl_{std::make_shared<{{ unpacked_class }}>(std::move(_message), _flatbuf)} {}

// Evolve

{% set comma = joiner(", ") %}
{{ class_name }} {{ class_name }}::evolve (
{% for field in fields %}
  {{ comma() }} std::optional<{{ utils.cpp_type(field.value.type) }}> {# -#}
    _{{ utils.escape(field.name) }}
{% endfor %}
) const {
  return {{ class_name }}({{ mutable_class }}(
  {% set comma = joiner(", ") %}
  {% for field in fields %}
    {% set field_name = utils.escape(field.name) %}
    {{ comma() }} _{{ field_name }} ? std::move(*_{{ field_name -}}
      ) : this->{{ field_name }}()
  {% endfor %}
  ));
}

// Operators

const {{ class_name }}::value_variant_type
    {{ class_name }}::operator[](const std::string &_key) const {
  return get_from_{{ class_name }}_by_key(*this, _key);
}

bool operator== (const {{ class_name }} &_lhs, const {{ class_name }} &_rhs){
  return is_{{ class_name }}_eq(_lhs, _rhs);
}
bool operator!= (const {{ class_name }} &_lhs, const {{ class_name }} &_rhs){
  return is_{{ class_name }}_ne(_lhs, _rhs);
}

std::ostream& operator<< (std::ostream &_stream, const {{ class_name }} &_obj) {
  return print_{{ class_name }}(_stream, _obj);
}


// Builder

flatbuffers::Offset<{{ flatbuffer_class }}>
build(
    flatboobs::BuilderContext &_context,
    const {{ class_name }} &_table,
    bool _is_root
) {

  if (!_is_root && !_table.content_id())
    return flatbuffers::Offset<{{ flatbuffer_class }}>{0};

  auto it = _context.offset_map().find(_table.content_id());
  if (it != _context.offset_map().end())
    return flatbuffers::Offset<{{ flatbuffer_class }}>{it->second};

  // Build dependencies

{% for field in fields|sort(attribute="value.type.inline_size") %}
{% if field.value.type.base_type == BaseType.STRUCT
    and not field.value.type.definition.fixed
    or field.value.type.base_type == BaseType.VECTOR %}
  // {{ field.name }}
  {{ utils.cpp_type(field.value.type) }} {{ field.name }}_value = {# -#}
    _table.{{ utils.escape(field.name) }}();
  {{ utils.offset_type(field.value.type) }} {{ field.name }}_offset {};
  if ({{ field.name }}_value.content_id())
    {{ field.name }}_offset = build(_context, {{ field.name }}_value, false);

{% endif %}
{% endfor %}

  // Build this table

  flatbuffers::FlatBufferBuilder *fbb = _context.builder();
  flatbuffers::uoffset_t start;
  start = fbb->StartTable();

{% for field in fields|sort(attribute="value.type.inline_size") %}
  // {{ field.name }}
{% if field.value.type.definition is instance_of("EnumDef")
    and field.value.type.base_type != BaseType.VECTOR%}
  fbb->AddElement<{{ utils.flatbuffer_type(field.value.type) }}>(
    {{ flatbuffer_class }}::VT_{{ field.name|upper }},
    static_cast<{{ utils.flatbuffer_type(field.value.type) }}>(
      _table.{{ utils.escape(field.name) }}()), {{ field.value.constant }});

{% elif field.value.type.base_type.is_scalar() %}
  fbb->AddElement<{{ utils.flatbuffer_type(field.value.type) }}>(
    {{ flatbuffer_class }}::VT_{{ field.name|upper }},
    _table.{{ utils.escape(field.name) }}(),
    {{ field.value.constant }}
    );

{% elif field.value.type.base_type == BaseType.STRUCT
    and field.value.type.definition.fixed %}
  {{ utils.cpp_type(field.value.type) }} {{ field.name }}_value = _table.
     {{- utils.escape(field.name) }}();
  if({{ field.name }}_value != {{ utils.cpp_type(field.value.type) }}())
    fbb->AddStruct({{ flatbuffer_class }}::VT_{{ field.name|upper -}}
                   , &{{ field.name }}_value);

{% elif field.value.type.base_type == BaseType.STRUCT
    and not field.value.type.definition.fixed
    or field.value.type.base_type == BaseType.VECTOR %}
  if (!{{- field.name }}_offset.IsNull())
    fbb->AddOffset({{ flatbuffer_class }}::VT_{{ field.name|upper -}}
                   , {{ field.name }}_offset);

{% else %}
  // TODO {{ field }}

{% endif %}
{% endfor %}
  flatbuffers::uoffset_t end = fbb->EndTable(start);
  _context.offset_map()[_table.content_id()] = end;
  flatbuffers::Offset<{{ flatbuffer_class }}> offset {end};

  if (_is_root) {
  {% if struct_def == parser.root_struct_def %}
    {% set file_identifier = parser.file_identifier %}
    static const char* identifier = "{{ parser.file_identifier }}";
  {% else %}
    static const char* identifier = nullptr;
  {% endif %}
    fbb->Finish(offset, identifier);
  }

  return offset;
}

// Pack/unpack

flatboobs::Message {{ class_name }}::pack() const {
  return flatboobs::pack<{{ class_name }}>(*this);
}
{{ class_name }} {{ class_name }}::unpack(flatboobs::Message _message) {
  return flatboobs::unpack<{{ class_name }}>(std::move(_message));
}

{#
// vim: syntax=cpp
// vim: tabstop=2
// vim: shiftwidth=2
#}
