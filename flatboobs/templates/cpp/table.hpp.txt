{% set class_name = utils.class_name(struct_def) %}
{% set flatbuffer_class = utils.flatbuffer_class(struct_def) %}
{% set default_class = utils.default_class(struct_def) %}
{% set unpacked_class = utils.unpacked_class(struct_def) %}
{% set mutable_class = utils.mutable_class(struct_def) %}
{% set impl_factory = utils.implement(struct_def) %}
{% set fields = struct_def.fields|rejectattr("attributes.deprecated")|list %}


/* {{ class_name }} */

class {{ flatbuffer_class }};
struct {{ mutable_class }};

// Implementation factory

class {{ class_name }} {
public:
  using flatbuffer_type = {{ flatbuffer_class }};
  using value_variant_type = {{ utils.cpp_variant_type(
      fields|map("attr", "value")|map("attr", "type")) }};

  // Abstract implementation
  class AbstractImpl {
  public:

    virtual ~AbstractImpl() = default;

    // Getters
  {% for field in fields %}
    virtual {{ utils.cpp_type(field.value.type) }} {{
        utils.escape(field.name) }}() const = 0;
  {% endfor %}

    virtual flatboobs::content_id_t content_id() const = 0;
    virtual const flatboobs::Message *source_message() const = 0;

  };

  // Constructor
  {{ class_name }}();
  {{ class_name }}({{ mutable_class }});
  {{ class_name }}(flatboobs::Message);
  {{ class_name }}(flatboobs::Message, const {{ flatbuffer_class }} *);
  {{ class_name }}(
  {% for field in fields %}
    {{ utils.cpp_type(field.value.type) }} _{{ utils.escape(field.name) }}
    {{- "," if not loop.last }}
  {% endfor %}
  );

  // Constructor that invokes implementation factory
  // Could be used to convert any kind of data to this type.
  // Example:
  //   {{ unpacked_class }} {{ impl_factory }}(flatboobs::Message _message) {
  //     return {{ unpacked_class }}(std::move(_message));
  //   }
  template <typename ...Ts> {{ class_name }}(Ts... _args) {
    auto impl_proxy = {{ utils.implement(struct_def) }}(std::forward<Ts>(_args)...);
    impl_ = std::dynamic_pointer_cast<const AbstractImpl>(
        std::make_shared<const decltype(impl_proxy)>(std::move(impl_proxy)));
  }

  // Metadata
  static constexpr std::string_view fully_qualified_name() {
    return "{{ struct_def.fully_qualified_name }}";
  }
  static constexpr std::string_view file_identifier() {
  {% if struct_def == parser.root_struct_def %}
    return "{{ parser.file_identifier }}";
  {% else %}
    return "";
  {% endif %}
  }
  static constexpr std::array<std::string_view, {{ fields|count }}> keys() {
    return { {{ fields|map("attr", "name")|map("quote")|join(", ")}} };
  }

  // Getters
{% for field in fields %}
  inline {{ utils.cpp_type(field.value.type) }} {{
      utils.escape(field.name) }}() const {
    return impl_->{{ utils.escape(field.name) }}(); }
{% endfor %}

  inline flatboobs::content_id_t content_id() const {
    return impl_->content_id(); }
  inline const flatboobs::Message *source_message() const {
    return impl_->source_message(); }

  // Evolve
  {{ class_name }} evolve (
  {% set comma = joiner(", ") %}
  {% for field in fields %}
    {{ comma() }} std::optional<{{ utils.cpp_type(field.value.type) }}> {# -#}
      _{{ utils.escape(field.name) }}
  {% endfor %}
  ) const;

  // Operators
  const value_variant_type operator[](const std::string &_key) const;
  friend bool operator== (const {{ class_name }}&, const {{ class_name }}&);
  friend bool operator!= (const {{ class_name }}&, const {{ class_name }}&);
  friend std::ostream &operator<< (std::ostream&, const {{ class_name }}&);

private:
  std::shared_ptr<const AbstractImpl> impl_;


};


// Builder

flatbuffers::Offset<{{ flatbuffer_class }}>
build(flatboobs::BuilderContext &, const {{ class_name }} &, bool _is_root = true);


{#
// vim: syntax=cpp
// vim: tabstop=2
// vim: shiftwidth=2
#}
