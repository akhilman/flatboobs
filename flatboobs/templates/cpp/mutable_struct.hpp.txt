{% set class_name = utils.class_name(struct_def) %}
{% if struct_def.fixed %}
  {% set struct_name = class_name %}
  {% set override = "" %}
{% else %}
  {% set struct_name = utils.mutable_class(struct_def) %}
  {% set override = "override" %}
{% endif %}
{% set fields = struct_def.fields|rejectattr("attributes.deprecated")|list %}

/* {{ struct_name }} */

{% if struct_def.fixed %}
struct alignas({{ struct_def.minalign }}) {{ struct_name }}
{% else %}
struct  {{ struct_name }} : public {{ class_name }}::AbstractImpl
{% endif %} {

  using value_variant_type = {{ utils.cpp_variant_type(
      fields|map("attr", "value")|map("attr", "type")) }};

  // Constructor
  {{ struct_name }}();
  {{ struct_name }}(
  {% for field in fields %}
    {{ utils.cpp_type(field.value.type) }} _{{ utils.escape(field.name) }}
    {{- "," if not loop.last }}
  {% endfor %}
  );

  // Metadata
  static constexpr std::string_view fully_qualified_name() {
    return "{{ struct_def.fully_qualified_name }}";
  }
  static constexpr std::array<std::string_view, {{ fields|count }}> keys() {
    return { {{ fields|map("attr", "name")|map("quote")|join(", ")}} };
  }

{% if not struct_def.fixed %}
  flatboobs::content_id_t content_id() const override {
    return flatboobs::content_id_t(this);
  }
  const flatboobs::Message *source_message() const override {
    return nullptr;
  }
{% endif %}

  // Getters
{% for field in fields %}
  {{ utils.cpp_type(field.value.type) }} {{
    utils.escape(field.name) }}() const {{ override }}{
    return {{ utils.escape(field.name) }}_;
  }
{% endfor %}

  // Setters
{% for field in fields %}
  inline void set_{{ utils.escape(field.name) }}(
      {{- utils.cpp_type(field.value.type) }} _value) {
    {{ utils.escape(field.name) }}_ = std::move(_value);
  }
{% endfor %}

  // Evolve
  {{ struct_name }} evolve (
  {% set comma = joiner(", ") %}
  {% for field in fields %}
    {{ comma() }} std::optional<{{ utils.cpp_type(field.value.type) }}> {# -#}
      _{{ utils.escape(field.name) }}
  {% endfor %}
  );

  // Operators
  const value_variant_type operator[](const std::string &_key) const;
  friend bool operator== (const {{ struct_name }}&, const {{ struct_name }}&);
  friend bool operator!= (const {{ struct_name }}&, const {{ struct_name }}&);
  friend std::ostream& operator<< (std::ostream&, const {{ struct_name }}&);

  // Fields
{% for field in fields %}
  {{ utils.cpp_type(field.value.type) }} {{utils.escape(field.name) }}_;
{% endfor %}

};

{% if struct_def.fixed %}
static_assert(sizeof({{ struct_name }}) == {{ struct_def.bytesize -}}
              , "compiler breaks packing rules");
{% endif %}


{#
// vim: syntax=cpp
// vim: tabstop=2
// vim: shiftwidth=2
#}
