{% set flatbuf_type = struct_def.name|escape_cpp_keyword %}
{% set class_name = struct_def|lazy_class_name %}
{% set fields = struct_def.fields|rejectattr("attributes.deprecated")|list %}
{% set extra_keywords = [
  "get", "keys", "data", "is_dirty", "build", "pack", "unpack", "content_id",
  "fully_qualified_name", "default_values",
  "message_", "flatbuf_", "dirty_values_", "VTable",
  ] %}

/* {{ class_name }} */

// Constructors

{{ class_name }}::{{ class_name }}(
    std::shared_ptr<const flatboobs::IByteData> message,
    const flatbuf_type *flatbuf
    ) : message_{message}, flatbuf_{flatbuf}, dirty_{false}, dirty_values_{}
    {}

{{ class_name }}::{{ class_name }}(
    {% for field in fields %}
      {{ field.value.type
          |to_cpp_type(const=True) }} &_{{ field.name|escape_cpp_keyword }}
        {{- "," if not loop.last }}
    {% endfor %}
    ) : message_{}, flatbuf_{}, dirty_{true},
     dirty_values_{
      {% for field_name in fields|map("attr", "name")
            |map("escape_cpp_keyword") %}
          _{{ field_name }} {{- "," if not loop.last }}
      {% endfor %}
     }
    {}

// Operators

{{ class_name }}::value_type_variant
    {{ class_name }}::operator[](const std::string &key) const
{
{% for field in fields %}
  if (key == "{{ field.name }}")
    return {{ field.name|escape_cpp_keyword|escape_keyword(extra_keywords) }}();
{% endfor %}
  throw flatboobs::key_error(key);
}
std::ostream& operator<< (std::ostream &stream, {{ class_name }} &src)
{
  stream << "{{ flatbuf_type }}("
  {% for field in fields %}
      << "{{ field.name }}="
  {% if field.value.type.base_type == BaseType.BOOL %}
      << (src.{{ field.name|escape_cpp_keyword|escape_keyword(extra_keywords) }}()
          ? "true" : "false")
  {% elif field.value.type.base_type.is_scalar()
        and field.value.type.base_type.is_one_byte() %}
      << (int)src.{{ field.name|escape_cpp_keyword|escape_keyword(extra_keywords) }}()
  {% elif field.value.type.base_type.is_scalar() %}
      << src.{{ field.name|escape_cpp_keyword|escape_keyword(extra_keywords) }}()
  {% elif field.value.type.base_type == BaseType.STRING %}
    << '"' << src.{{ field.name|escape_cpp_keyword|escape_keyword(extra_keywords) }}() << '"'
  {% else %}
    << (src.{{ field.name|escape_cpp_keyword|escape_keyword(extra_keywords) }}()
          ? *(src.{{ field.name|escape_cpp_keyword|escape_keyword(extra_keywords) }}())
          : "NULL")
  {% endif %}
  {% if not loop.last %}
    << ", "
  {% endif %}
  {% endfor %}
    << ")";
  return stream;
};

// Getters

{% for field in fields %}
{{ field.value.type|to_cpp_type }} {{ class_name -}}
    ::{{ field.name|escape_cpp_keyword|escape_keyword(extra_keywords) }}() const
{
  if (is_dirty())
    return dirty_values_.{{ field.name|escape_cpp_keyword }}_;
{% if field.value.type.base_type.is_scalar() %}
  return flatbuf_->{{ field.name|escape_cpp_keyword }}();
{% else %}
  return nullptr;  // TODO {{ field.name }}
{% endif %}
}

{% endfor %}

// Builder

const size_t {{ class_name }}::content_id() const
{
  if (is_dirty())
    return (size_t) this;
  return (size_t) flatbuf_;
}

const bool {{ class_name }}::is_dirty() const
{
  return dirty_;
}

flatbuffers::Offset<{{ flatbuf_type }}> {{ class_name }}::build(
    flatbuffers::FlatBufferBuilder & _fbb,
    std::map<size_t, flatbuffers::uoffset_t> &_offset_map
) const {

  auto it = _offset_map.find(size_t(this));
  if (it != _offset_map.end())
    return flatbuffers::Offset<{{ flatbuf_type }}>{it->second};

  {{ flatbuf_type }}Builder builder{_fbb};
{% for field in fields|sort(attribute="value.type.inline_size") %}
{% if field.value.type.base_type.is_scalar() %}
  builder.add_{{ field.name|escape_cpp_keyword }}({{
    field.name|escape_cpp_keyword|escape_keyword(extra_keywords) }}());
{% else %}
  // TODO {{ field }}
{% endif %}
{% endfor %}
  auto offset = builder.Finish();

  _offset_map[size_t(this)] = offset.o;
  return offset;
}


// Verify
bool {{ class_name }}::verify(const std::string_view _message) {
  auto verifier = flatbuffers::Verifier(
    reinterpret_cast<const uint8_t *>(_message.data()),
    _message.size()
    );
  return Verify{{ flatbuf_type }}Buffer(verifier);
}

bool {{ class_name }}::verify(const flatboobs::IByteData &_message) {
  return verify(_message.str());
}


// Pack / Unpack

void {{ class_name }}::pack(
    flatboobs::BuiltByteData &_message) const {
  flatbuffers::FlatBufferBuilder builder {1024};
  std::map<size_t, flatbuffers::uoffset_t> offset_map {};
  flatbuffers::Offset<{{ flatbuf_type }}> offset;
  offset = build(builder, offset_map);
  Finish{{ flatbuf_type }}Buffer(builder, offset);
  _message.steal_from_builder(std::move(builder));
}

// void {{ class_name }}::pack(std::string &_bytes) const {
//     flatboobs::BuiltByteData message;
//     pack(message);
//     _bytes = std::string(message.data(), message.size());
// }

const {{ class_name }} {{ class_name }}::unpack(
    std::shared_ptr<const flatboobs::IByteData> _message) {
  auto verifier = flatbuffers::Verifier(
    reinterpret_cast<const uint8_t *>(_message->data()),
    _message->size()
    );
  bool ok = Verify{{ flatbuf_type }}Buffer(verifier);
  if (!ok)
    throw flatboobs::unpack_error("Bad message");
  return {{ class_name }}(_message, Get{{ flatbuf_type }}(_message->data()));

}
/*const {{ class_name }} {{ class_name }}::unpack(std::string &_bytes) {

}*/

{#
// vim: syntax=cpp
// vim: tabstop=2
// vim: shiftwidth=2
#}
