/*
 * Generated by FlatBoobs from {{ parser.root_struct_def.file|basename }}
 */

#ifndef {{ output_file|include_guard }}
#define {{ output_file|include_guard }}

#include <functional>
#include <optional>
#include <variant>

#include <flatboobs/container.h>
#include <flatboobs/exceptions.h>
#include <flatbuffers/flatbuffers.h>

// Requires headers generated by `flatc --cpp --scoped-enums`
#include "{{ parser.root_struct_def.file|stem + "_generated.h" }}"
{% for file in parser.native_included_files %}
#include "{{ file|stem + "_generate_l.h" }}"
{% endfor %}


/*
 * Forvard declaration of structs
 */
{% for group in parser.structs
    | selectattr("file", "equalto", parser.root_struct_def.file)
    | groupby("defined_namespace") %}
{% for component in group.grouper.components %}
namespace {{ component }} {
{% endfor %}

{% for struct_def in group.list|sort(attribute="name") %}
class {{ struct_def|lazy_class_name }};
{% endfor %}

{% for component in group.grouper.components|reverse %}
}  // {{ component }}
{% endfor %}
{% endfor %}


/*
 * Declaration of structs
 */
{% for group in parser.structs
    | selectattr("file", "equalto", parser.root_struct_def.file)
    | groupby("defined_namespace") %}
{% for component in group.grouper.components %}
namespace {{ component }} {
{% endfor %}

{% for struct_def in group.list|sort(attribute="name") %}
{# {% set base_class = "Struct" if struct_def.fixed else "Table" %} #}

{% include "lazy.h/table.txt" %}
{% endfor %}

{% for component in group.grouper.components|reverse %}
}  // {{ component }}
{% endfor %}
{% endfor %}

{% if options["header_only"] %}
{% include "lazy.cpp/main.txt" %}
{% endif %}

#endif  // {{ output_file|include_guard }}

{#
// vim: syntax=cpp
#}
