{% set flatbuf_type = struct_def.name|escape_cpp_keyword %}
{% set class_name = struct_def|lazy_class_name %}
{% set fields = struct_def.fields|rejectattr("attributes.deprecated")|list %}

{% if struct_def.fixed %}
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT({{ struct_def.minalign }})
{% endif %}
struct {{ class_name }}T final {
{% for field in fields %}
  {{ field.value.type|to_cpp_type }} {{ field.name|escape_cpp_keyword }};
{% endfor %}

{{ class_name }}T(
    {% for field in fields %}
      {% if field.value.type.base_type.is_scalar() %}
        {% set default_value = field.value.constant %}
      {% else %}
        {% set default_value = "nullptr" %}
      {% endif %}
      {{ field.value.type
          |to_cpp_type(const=True) }} {# -#}
        &{{ field.name|escape_cpp_keyword }}__ = {{ default_value }}
        {{- "," if not loop.last }}
    {% endfor %}
    ) :
    {% for field_name in fields|map("attr", "name")|map("escape_cpp_keyword") %}
        {{ field_name }} { {{ field_name }}__ }
        {{- "," if not loop.last }}
    {% endfor %}
    {}
};
{% if struct_def.fixed %}
FLATBUFFERS_STRUCT_END({{ class_name }}T, {{ struct_def.bytesize }});
{% endif %}

class {{ class_name }} {
public:
  using flatbuf_type = {{ flatbuf_type }};
  using values_type = {{ class_name }}T;
  using value_type_variant = std::variant<{{
    fields|map("attr", "value")|map("attr", "type")
      |map("to_cpp_type", const=True)
      |unique|sort|join(", ")
  }}>;

  // Constructors
  // {{ class_name }}() ;
  {{ class_name }}(std::shared_ptr<const flatboobs::LazyBufMessage<{{ class_name
    }}>> message, const flatbuf_type *flatbuf);
  {{ class_name }}(const values_type &values);
  {{ class_name }}(
    {% for field in fields %}
      {% if field.value.type.base_type.is_scalar() %}
        {% set default_value = field.value.constant %}
      {% else %}
        {% set default_value = "nullptr" %}
      {% endif %}
      {{ field.value.type
          |to_cpp_type(const=True) }} {# -#}
        &{{ field.name|escape_cpp_keyword }}__ = {{ default_value }}
        {{- "," if not loop.last }}
    {% endfor %}
    );


  // Operators
  friend std::ostream& operator<< (std::ostream&, {{ class_name }}&);

  // Metadata
  static constexpr std::string_view _name() {
    return "{{ struct_def.name }}";
  };
  static constexpr std::string_view _fully_qualified_name() {
    return "{{ struct_def.fully_qualified_name }}";
  };

  // Getters
{% for field in fields %}
{% if field.value.type.base_type.is_scalar() %}
  {{ field.value.type|to_cpp_type(const=True) }}
  {#- #} {{ field.name|escape_cpp_keyword }}() const;
{% else %}
  // TODO {{ field.name }}
{% endif %}
{% endfor %}

  static constexpr std::array<std::string_view, {{ fields|count }}> _keys() {
    return { {{ fields|map("attr", "name")
                |escape_cpp_keyword|map("quote")|join(", ")}} };
  };
  const value_type_variant _get(const std::string &key) const;
{% if struct_def.fixed %}
  const std::string_view _data const ();
{% else %}
  // _data() available only for fixed structs
{% endif %}

  // Defaults
{% for field in fields %}
{% if field.value.type.base_type.is_scalar() %}
  static constexpr {{ field.value.type|to_cpp_type }} default_
  {{- field.name|escape_cpp_keyword }}() { return {{ field.value.constant }}; };
{% elif field.value.type.base_type == BaseType.STRING %}
  static constexpr std::string_view default_
  {{- field.name|escape_cpp_keyword }}() { return ""; };
{% else %}
  static constexpr nullptr_t default_
  {{- field.name|escape_cpp_keyword }}() { return nullptr; };
{% endif %}
{% endfor %}

  // Builder
  const bool __is_dirty() const;
  flatbuffers::Offset<flatbuf_type>
  __build(flatbuffers::FlatBufferBuilder *) const;

private:
  std::shared_ptr<const flatboobs::LazyBufMessage<{{ class_name }}>> __message;
  const flatbuf_type *__flatbuf;
  values_type __values;
  bool __dirty;

};

{#
// vim: syntax=cpp
#}
