{% set flatbuf_type = struct_def.name|escape_cpp_keyword %}
{% set class_name = struct_def|lazy_class_name %}
{% set fields = struct_def.fields|rejectattr("attributes.deprecated")|list %}
{% set extra_keywords = [
  "get", "keys", "data", "is_dirty", "build", "pack", "unpack", "content_id",
  "fully_qualified_name", "default_values",
  "message_", "flatbuf_", "dirty_values_", "VTable",
  ] %}


class {{ class_name }} {
public:

  using flatbuf_type = {{ flatbuf_type }};
  using value_type_variant = std::variant<{{
    fields|map("attr", "value")|map("attr", "type")
      |map("to_cpp_type", const=True)
      |unique|sort|join(", ")
  }}>;

  // Constructors
  explicit {{ class_name }}(
    std::shared_ptr<const flatboobs::IByteData> message,
    const flatbuf_type *flatbuf
    );
  explicit {{ class_name }}(
    {% for field in fields %}
      {% if field.value.type.base_type.is_scalar() %}
        {% set default_value = field.value.constant %}
      {% else %}
        {% set default_value = "nullptr" %}
      {% endif %}
      {{ field.value.type
          |to_cpp_type(const=True) }} {# -#}
        &_{{ field.name|escape_cpp_keyword }} = {{ default_value }}
        {{- "," if not loop.last }}
    {% endfor %}
    );

  // Operators
  value_type_variant operator[](const std::string &key) const;
  friend std::ostream& operator<< (std::ostream&, {{ class_name }}&);

  // Metadata
  static constexpr std::string_view fully_qualified_name() {
    return "{{ struct_def.fully_qualified_name }}";
  };
  static constexpr std::array<std::string_view, {{ fields|count }}> keys() {
    return { {{ fields|map("attr", "name")
                |escape_cpp_keyword|map("quote")|join(", ")}} };
  };

  // Getters
{% for field in fields %}
{% if field.value.type.base_type.is_scalar() %}
  {{ field.value.type|to_cpp_type }} {{ field.name
            |escape_cpp_keyword|escape_keyword(extra_keywords) }}() const;
{% else %}
  // TODO {{ field.name }}
{% endif %}
{% endfor %}

  // Defaults
  struct default_values {
  {% for field in fields %}
  {% if field.value.type.base_type.is_scalar() %}
    static constexpr {{ field.value.type|to_cpp_type }}
    {{field.name|escape_cpp_keyword }}() { return {{ field.value.constant }}; };
  {% elif field.value.type.base_type == BaseType.STRING %}
    static constexpr std::string_view
    {{field.name|escape_cpp_keyword }}() { return ""; };
  {% else %}
    static constexpr nullptr_t
    {{field.name|escape_cpp_keyword }}() { return nullptr; };
  {% endif %}
  {% endfor %}
  };

  // Builder
  const size_t content_id () const;
  const bool is_dirty() const;
  flatbuffers::Offset<flatbuf_type> build(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::map<size_t, flatbuffers::uoffset_t> &_offset_map) const;

  // Verify
  static bool verify(const std::string_view);
  static bool verify(const flatboobs::IByteData&);

  // Pack / Unpack
  void pack(flatboobs::BuiltByteData &_message) const;
  // void pack(std::string &_bytes) const;
  static const {{ class_name }}
  unpack(std::shared_ptr<const flatboobs::IByteData> _message);
  // static const {{ class_name }} unpack(std::string &_bytes);


private:
  std::shared_ptr<const flatboobs::IByteData> message_;
  const flatbuf_type *flatbuf_;

  bool dirty_;
  struct {
  {% for field in fields %}
    {{ field.value.type|to_cpp_type }} {{ field.name|escape_cpp_keyword }}_;
  {% endfor %}
  } dirty_values_;

};

{#
// vim: syntax=cpp
// vim: tabstop=2
// vim: shiftwidth=2
#}
